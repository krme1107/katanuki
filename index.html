<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>å‹æŠœãã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ¡ç‚¹ãƒ»ã‚¹ãƒˆãƒƒãƒ—ï¼‰</title>
  <style>
    body{
      margin:0;
      font-family:-apple-system, system-ui, "Hiragino Sans", "Noto Sans JP", sans-serif;
      background:#f6efe3;
      display:flex; flex-direction:column; align-items:center;
      user-select:none; -webkit-user-select:none;
    }
    header{
      width:min(920px, 96vw);
      padding:14px 10px 8px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .title{ font-weight:900; letter-spacing:.02em; }
    .panel{
      width:min(920px, 96vw);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:0 10px 10px;
    }
    .chip{
      background:#fff; border:1px solid rgba(0,0,0,.12);
      border-radius:999px; padding:8px 12px; font-size:13px;
      display:flex; align-items:center; gap:8px;
      box-shadow:0 1px 0 rgba(0,0,0,.04);
    }
    button{
      border:none; background:#222; color:#fff;
      padding:10px 12px; border-radius:12px; font-weight:800;
      cursor:pointer;
    }
    button.secondary{ background:#fff; color:#222; border:1px solid rgba(0,0,0,.18); }
    button.danger{ background:#d63a3a; }
    .wrap{ width:min(920px, 96vw); padding:0 10px 18px; }
    canvas{
      width:100%; height:auto;
      border-radius:18px;
      box-shadow:0 14px 40px rgba(0,0,0,.12);
      background:#f6efe3;
      touch-action:none;
    }
    .hint{
      width:min(920px, 96vw);
      padding:0 14px 18px;
      color:rgba(0,0,0,.65);
      font-size:13px; line-height:1.55;
    }
    .toast{
      position:fixed; left:50%; top:18px; transform:translateX(-50%);
      background:rgba(20,20,20,.92); color:#fff;
      padding:10px 14px; border-radius:999px;
      font-weight:900; letter-spacing:.02em;
      opacity:0; pointer-events:none;
      transition:opacity .25s ease, transform .25s ease;
      z-index:50; white-space:nowrap;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(6px); }

    /* Modal */
    .modal{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      z-index:100;
      padding:18px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(980px, 96vw);
      background:#fff; border-radius:18px;
      box-shadow:0 18px 50px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(0,0,0,.08);
    }
    .modalHead h2{ margin:0; font-size:16px; letter-spacing:.02em; }
    .grid{
      display:grid;
      grid-template-columns:repeat(4, 1fr);
      gap:10px;
      padding:14px;
    }
    @media (max-width:640px){
      .grid{ grid-template-columns:repeat(3, 1fr); }
    }
    .card{
      border:1px solid rgba(0,0,0,.10);
      border-radius:14px;
      overflow:hidden;
      background:#faf7f1;
      position:relative;
    }
    .thumb{
      width:100%;
      aspect-ratio:1/1;
      display:block;
      object-fit:cover;
    }
    .lock{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.45);
      color:#fff;
      font-weight:900;
      letter-spacing:.08em;
      font-size:14px;
    }
    .cap{
      padding:8px 10px;
      font-size:12px;
      color:rgba(0,0,0,.7);
      display:flex; justify-content:space-between; gap:8px;
    }
    .small{
      font-size:12px; color:rgba(0,0,0,.6);
      padding:0 14px 14px;
    }

    /* Result overlay (canvasä¸Šã«æãã‘ã©ã€è¦‹ã‚„ã™ãã™ã‚‹è£œåŠ©) */
    .resultLine{
      font-weight:900;
      letter-spacing:.04em;
    }
  </style>
</head>
<body>
  <div class="toast" id="toast"></div>

  <header>
    <div class="title">ğŸ å‹æŠœãã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ¡ç‚¹ãƒ»ã‚¹ãƒˆãƒƒãƒ—ï¼‰</div>
    <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
      <button class="secondary" id="btnGallery">ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</button>
      <button class="secondary" id="btnNext">æ¬¡ã®çµµ</button>
      <button class="secondary" id="btnReset">ãƒªã‚»ãƒƒãƒˆ</button>
      <button class="danger" id="btnStop">ã‚¹ãƒˆãƒƒãƒ—ï¼ˆæ¡ç‚¹ï¼‰</button>
    </div>
  </header>

  <div class="panel">
    <div class="chip">
      ã‚¹ã‚³ã‚¢ <span id="scoreText">0</span> ç‚¹ï¼ˆ<span id="rankText">-</span>ï¼‰
    </div>
    <div class="chip">
      è¼ªéƒ­ã‚«ãƒãƒ¼ <span id="covText">0%</span>
    </div>
    <div class="chip">
      ã¯ã¿å‡ºã— <span id="ovrText">0%</span>
    </div>
    <div class="chip">
      ä»Šã®çµµ <span id="artText">---</span>
    </div>
    <div class="chip">
      é‡ <span id="toolText">ãµã¤ã†</span>
      <button class="secondary" id="btnTool" style="padding:7px 10px;border-radius:999px;">æ›¿ãˆã‚‹</button>
    </div>
  </div>

  <div class="wrap">
    <canvas id="c" width="900" height="1200"></canvas>
  </div>

  <div class="hint">
    ãƒ»é€æ˜èƒŒæ™¯PNGãªã‚‰ã€ãã®ã‚­ãƒ£ãƒ©ã®<strong>è¼ªéƒ­</strong>ã«æ²¿ã£ã¦æ¡ç‚¹ã§ãã¾ã™ã€‚<br/>
    ãƒ»è¼ªéƒ­ï¼ˆæ­£è§£å¸¯ï¼‰ã‚’å‰Šã‚‹ã»ã©é«˜å¾—ç‚¹ã€‚è¼ªéƒ­ä»¥å¤–ã¯ã€Œã¯ã¿å‡ºã—ã€ã§æ¸›ç‚¹ã€‚<br/>
    ãƒ»å¥½ããªã¨ã“ã‚ã§ <strong>ã‚¹ãƒˆãƒƒãƒ—ï¼ˆæ¡ç‚¹ï¼‰</strong> ã‚’æŠ¼ã—ã¦çµæœç¢ºå®šï¼<br/>
    ãƒ»ç¢ºå®šã™ã‚‹ã¨ã€ãã®çµµãŒã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«è§£æ”¾ï¼†ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ä¿å­˜ã•ã‚Œã¾ã™ã€‚
  </div>

  <!-- Gallery Modal -->
  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalHead">
        <h2>ğŸ–¼ ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</h2>
        <div style="display:flex; gap:8px;">
          <button class="secondary" id="btnClear">ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆ</button>
          <button id="btnClose">é–‰ã˜ã‚‹</button>
        </div>
      </div>
      <div class="small" id="colStat">---</div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const toast     = document.getElementById('toast');
  const scoreText = document.getElementById('scoreText');
  const rankText  = document.getElementById('rankText');
  const covText   = document.getElementById('covText');
  const ovrText   = document.getElementById('ovrText');
  const toolText  = document.getElementById('toolText');
  const artText   = document.getElementById('artText');

  const btnReset   = document.getElementById('btnReset');
  const btnNext    = document.getElementById('btnNext');
  const btnTool    = document.getElementById('btnTool');
  const btnGallery = document.getElementById('btnGallery');
  const btnStop    = document.getElementById('btnStop');

  // modal
  const modal   = document.getElementById('modal');
  const btnClose= document.getElementById('btnClose');
  const btnClear= document.getElementById('btnClear');
  const grid    = document.getElementById('grid');
  const colStat = document.getElementById('colStat');

  // ====== ã“ã“ã‚’å¢—ã‚„ã™ã ã‘ã§OKï¼ˆã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®çµµï¼‰ ======
  const ART_LIST = [
    { id:"001", name:"No.001", src:"art/001.png" },
    { id:"002", name:"No.002", src:"art/002.png" },
    { id:"003", name:"No.003", src:"art/003.png" },
    { id:"004", name:"No.004", src:"art/004.png" },
    { id:"005", name:"No.005", src:"art/005.png" },
  ];
  // =========================================================

  const STORE_KEY = "katanuki_collection_scorestop_v1";
  const BEST_KEY  = "katanuki_best_scorestop_v1";

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 1300);
  }

  function loadUnlocked(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      return raw ? JSON.parse(raw) : {};
    }catch(e){ return {}; }
  }
  function saveUnlocked(map){ localStorage.setItem(STORE_KEY, JSON.stringify(map)); }
  function clearUnlocked(){ localStorage.removeItem(STORE_KEY); }

  function loadBest(){
    try{
      const raw = localStorage.getItem(BEST_KEY);
      return raw ? JSON.parse(raw) : {};
    }catch(e){ return {}; }
  }
  function saveBest(best){ localStorage.setItem(BEST_KEY, JSON.stringify(best)); }

  // Offscreen layers
  const base = document.createElement('canvas');
  base.width=W; base.height=H;
  const bctx = base.getContext('2d');

  const sugar = document.createElement('canvas');
  sugar.width=W; sugar.height=H;
  const sctx = sugar.getContext('2d');

  // particles
  const particles = [];

  const state = {
    lastPt: null,
    toolIndex: 0,
    currentArtIndex: 0,
    frozen: false,      // ã‚¹ãƒˆãƒƒãƒ—å¾Œã¯æ“ä½œä¸å¯ï¼ˆãƒªã‚»ãƒƒãƒˆ/æ¬¡ã¸ã§è§£é™¤ï¼‰

    imgReady: false,
    img: null,
    imgRect: null,

    edgeMap: null,      // {w,h,band,bandCount}
    hitEdge: null,      // good é‡è¤‡é˜²æ­¢
    badMask: null,      // bad é‡è¤‡é˜²æ­¢

    // æ¡ç‚¹ç”¨
    goodCount: 0,
    badCount: 0,
    overWorkSum: 0,
    score: 0,
    rank: "-",
    coverage: 0,
    overcut: 0,

    showResult: false,
  };

  function toolParams(){
    // é‡ã®å¤ªã•ï¼ˆï¼å‰Šã‚Šã‚„ã™ã•ï¼‰
    if (state.toolIndex === 1){
      return { name:"ç´°ã„", radius: 7 };
    } else if (state.toolIndex === 2){
      return { name:"å¤ªã„", radius: 15 };
    }
    return { name:"ãµã¤ã†", radius: 11 };
  }

  function updateUI(){
    scoreText.textContent = Math.round(state.score);
    rankText.textContent  = state.rank;
    covText.textContent   = Math.round(state.coverage*100) + "%";
    ovrText.textContent   = Math.round(state.overcut*100) + "%";
    toolText.textContent  = toolParams().name;
    const art = ART_LIST[state.currentArtIndex];
    artText.textContent = art ? art.name : "---";
  }

  function roundRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r, y);
    c.arcTo(x+w, y, x+w, y+h, r);
    c.arcTo(x+w, y+h, x, y+h, r);
    c.arcTo(x, y+h, x, y, r);
    c.arcTo(x, y, x+w, y, r);
    c.closePath();
  }

  function drawBase(c){
    c.fillStyle = "#f6efe3";
    c.fillRect(0,0,W,H);

    // æœ¨ç›®
    c.save();
    c.globalAlpha = 0.18;
    c.fillStyle = "#7a4d2a";
    for(let y=760; y<H; y+=18){
      c.fillRect(0, y, W, 10);
    }
    c.restore();

    // æ•·ç´™
    c.save();
    c.fillStyle = "rgba(0,0,0,.06)";
    roundRect(c, 70, 170, W-140, H-320, 28);
    c.fill();
    c.restore();

    c.save();
    c.fillStyle = "#fffaf0";
    c.strokeStyle = "rgba(0,0,0,.08)";
    c.lineWidth = 3;
    roundRect(c, 60, 160, W-120, H-320, 28);
    c.fill();
    c.stroke();
    c.restore();

    c.save();
    c.fillStyle = "rgba(0,0,0,.6)";
    c.font = "900 36px -apple-system, system-ui, sans-serif";
    c.fillText("å‹æŠœãï¼ˆæ¡ç‚¹ï¼‰", 90, 120);
    c.font = "700 18px -apple-system, system-ui, sans-serif";
    c.fillText("è¼ªéƒ­ã‚’ãªãã£ã¦ã€å¥½ããªã¨ã“ã‚ã§ã‚¹ãƒˆãƒƒãƒ—ï¼", 90, 150);
    c.restore();
  }

  // cover crop è¨ˆç®—
  function coverCrop(imgW, imgH, dstW, dstH){
    const ir = imgW / imgH;
    const tr = dstW / dstH;
    let sx, sy, sw, sh;
    if (ir > tr){
      sh = imgH; sw = sh * tr;
      sx = (imgW - sw)/2; sy = 0;
    } else {
      sw = imgW; sh = sw / tr;
      sx = 0; sy = (imgH - sh)/2;
    }
    return {sx,sy,sw,sh};
  }

  // è¼ªéƒ­ãƒãƒƒãƒ—ç”Ÿæˆ
  function buildEdgeMapFromImage(img){
    const r = state.imgRect;
    if(!r) return null;

    const oc = document.createElement("canvas");
    oc.width = Math.floor(r.w);
    oc.height= Math.floor(r.h);
    const octx = oc.getContext("2d", { willReadFrequently:true });

    const cc = coverCrop(img.width, img.height, oc.width, oc.height);
    octx.clearRect(0,0,oc.width,oc.height);
    octx.drawImage(img, cc.sx, cc.sy, cc.sw, cc.sh, 0, 0, oc.width, oc.height);

    const data = octx.getImageData(0,0,oc.width,oc.height);
    const a = data.data;
    const w = oc.width, h = oc.height;

    const mask = new Uint8Array(w*h);
    const alphaTh = 12;
    for(let i=0;i<w*h;i++){
      mask[i] = (a[i*4+3] > alphaTh) ? 1 : 0;
    }

    const edge = new Uint8Array(w*h);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = y*w+x;
        if(mask[i]===0) continue;
        if(mask[i-1]===0 || mask[i+1]===0 || mask[i-w]===0 || mask[i+w]===0){
          edge[i]=1;
        }
      }
    }

    // âœ… å¸¯ã®å¤ªã•ï¼ˆé›£æ˜“åº¦èª¿æ•´ï¼‰ã“ã“å¤§äº‹ï¼
    const band = new Uint8Array(w*h);
    const R = 7; // â† å¤ªã‚ã«ã—ã¦ã€Œç°¡å˜ã€ã«ã—ã¦ã‚ã‚‹ï¼ˆ3ã ã¨é›£ã—ã„ï¼‰
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=y*w+x;
        if(edge[i]===0) continue;
        for(let yy=Math.max(0,y-R); yy<=Math.min(h-1,y+R); yy++){
          for(let xx=Math.max(0,x-R); xx<=Math.min(w-1,x+R); xx++){
            band[yy*w+xx]=1;
          }
        }
      }
    }

    let bandCount=0;
    for(let i=0;i<w*h;i++) if(band[i]) bandCount++;
    return { w, h, band, bandCount };
  }

  function drawSugar(c){
    c.save();
    c.fillStyle = "#f3cfa6";
    c.strokeStyle = "rgba(0,0,0,.14)";
    c.lineWidth = 4;
    roundRect(c, 150, 260, W-300, 640, 44);
    c.fill();
    c.stroke();

    // ç ‚ç³–ç²’
    c.save();
    c.globalAlpha = 0.16;
    for(let i=0;i<1050;i++){
      const x = 160 + Math.random()*(W-320);
      const y = 270 + Math.random()*620;
      const rr = Math.random()*1.8+0.4;
      c.beginPath();
      c.arc(x,y,rr,0,Math.PI*2);
      c.fillStyle = (Math.random()<0.7) ? "#fff" : "#d9b48c";
      c.fill();
    }
    c.restore();

    // ç”»åƒæ 
    const pad = 190;
    const x = pad, y = 300, w = W-pad*2, h = 560;
    state.imgRect = { x, y, w, h };

    if (state.imgReady && state.img){
      const img = state.img;
      const cc = coverCrop(img.width, img.height, w, h);

      c.save();
      roundRect(c, x, y, w, h, 28);
      c.clip();
      c.drawImage(img, cc.sx, cc.sy, cc.sw, cc.sh, x, y, w, h);
      c.restore();

      c.save();
      c.strokeStyle = "rgba(0,0,0,.12)";
      c.lineWidth = 4;
      roundRect(c, x, y, w, h, 28);
      c.stroke();
      c.restore();

      // ã‚¬ã‚¤ãƒ‰ï¼ˆè¼ªéƒ­å¸¯ï¼‰ã‚’è–„ãè¡¨ç¤ºï¼ˆç°¡å˜ã«ãªã‚‹ï¼‰
      if(state.edgeMap){
        c.save();
        c.globalAlpha = 0.10;
        c.fillStyle = "#000";
        const em = state.edgeMap;
        const imgData = c.createImageData(em.w, em.h);
        const d = imgData.data;
        for(let i=0;i<em.w*em.h;i++){
          if(em.band[i]) d[i*4+3] = 255;
        }
        const tmp = document.createElement("canvas");
        tmp.width = em.w; tmp.height = em.h;
        tmp.getContext("2d").putImageData(imgData,0,0);
        c.drawImage(tmp, x, y, w, h);
        c.restore();
      }
    } else {
      c.save();
      c.fillStyle = "rgba(0,0,0,.06)";
      roundRect(c, x, y, w, h, 28);
      c.fill();
      c.fillStyle = "rgba(0,0,0,.35)";
      c.font = "800 22px -apple-system, system-ui, sans-serif";
      c.fillText("ç”»åƒèª­ã¿è¾¼ã¿ä¸­...", 330, 590);
      c.restore();
    }

    c.restore();
  }

  function resetGame(keepArt=true){
    state.lastPt = null;
    state.frozen = false;
    state.showResult = false;

    // æ¡ç‚¹ãƒªã‚»ãƒƒãƒˆ
    state.goodCount = 0;
    state.badCount = 0;
    state.overWorkSum = 0;
    state.score = 0;
    state.rank = "-";
    state.coverage = 0;
    state.overcut = 0;

    if(state.edgeMap){
      state.hitEdge = new Uint8Array(state.edgeMap.w * state.edgeMap.h);
      state.badMask = new Uint8Array(state.edgeMap.w * state.edgeMap.h);
    } else {
      state.hitEdge = null;
      state.badMask = null;
    }

    bctx.clearRect(0,0,W,H);
    drawBase(bctx);

    sctx.clearRect(0,0,W,H);
    drawSugar(sctx);

    particles.length = 0;

    updateUI();
    showToast(keepArt ? "ã‚¹ã‚¿ãƒ¼ãƒˆï¼" : "æ¬¡ã®çµµï¼");
  }

  function loadCurrentImage(){
    state.imgReady = false;
    state.edgeMap = null;
    state.hitEdge = null;
    state.badMask = null;

    const art = ART_LIST[state.currentArtIndex];
    state.img = new Image();
    state.img.src = art.src;

    state.img.onload = () => {
      state.imgReady = true;

      // 1å›æç”»ã—ã¦imgRectç¢ºå®š
      resetGame(true);

      // è¼ªéƒ­ãƒãƒƒãƒ—ç”Ÿæˆ
      state.edgeMap = buildEdgeMapFromImage(state.img);
      if(!state.edgeMap || state.edgeMap.bandCount < 50){
        showToast("è¼ªéƒ­ãŒå¼±ã„ã‹ã‚‚â€¦(é€æ˜PNGæ¨å¥¨)");
      }

      // åæ˜ ã—ã¦å†ã‚¹ã‚¿ãƒ¼ãƒˆ
      resetGame(true);
    };

    state.img.onerror = () => {
      showToast("ç”»åƒãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‚ˆ: " + art.src);
      state.imgReady = false;
      resetGame(true);
    };
  }

  // ===== æ¡ç‚¹ =====
  function calcScore(){
    const em = state.edgeMap;
    if(!em) return;

    const coverage = state.goodCount / Math.max(1, em.bandCount); // 0..1
    const overcutDen = Math.max(1, state.goodCount + state.badCount);
    const overcut = state.badCount / overcutDen;                 // 0..1
    const care = Math.min(1, state.overWorkSum / 2500);          // 0..1 (é›‘ã•)

    // âœ… é›£æ˜“åº¦ã‚’ä¸‹ã’ã‚‹ï¼šã‚«ãƒãƒ¼ç‡å¯„ã‚Šã§è©•ä¾¡ã€ã¯ã¿å‡ºã—ã¯è»½ã‚ã«æ¸›ç‚¹
    let s = 100 * (0.85 * coverage + 0.15 * (1 - overcut)) - 6 * care;
    s = Math.max(0, Math.min(100, s));

    state.coverage = Math.max(0, Math.min(1, coverage));
    state.overcut  = Math.max(0, Math.min(1, overcut));
    state.score = s;

    state.rank =
      s >= 95 ? "S" :
      s >= 85 ? "A" :
      s >= 70 ? "B" :
      s >= 55 ? "C" : "D";
  }

  // ===== ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆè§£æ”¾ï¼‹ãƒ™ã‚¹ãƒˆï¼‰=====
  function unlockAndSaveBest(){
    const art = ART_LIST[state.currentArtIndex];

    // è§£æ”¾ï¼ˆæ¡ç‚¹ç¢ºå®šã§è§£æ”¾ï¼‰
    const unlocked = loadUnlocked();
    if(!unlocked[art.id]){
      unlocked[art.id] = true;
      saveUnlocked(unlocked);
    }

    // ãƒ™ã‚¹ãƒˆä¿å­˜
    const best = loadBest();
    const sc = Math.round(state.score);
    if(best[art.id] == null || sc > best[art.id]){
      best[art.id] = sc;
      saveBest(best);
    }
  }

  function openGallery(){
    renderGallery();
    modal.classList.add("show");
  }
  function closeGallery(){ modal.classList.remove("show"); }

  function renderGallery(){
    const unlocked = loadUnlocked();
    const best = loadBest();
    const total = ART_LIST.length;
    const got = ART_LIST.filter(a => unlocked[a.id]).length;
    colStat.textContent = `è§£æ”¾: ${got} / ${total}ã€€ï¼ˆã‚¹ãƒˆãƒƒãƒ—ã§æ¡ç‚¹â†’è§£æ”¾ï¼†ãƒ™ã‚¹ãƒˆä¿å­˜ï¼‰`;

    grid.innerHTML = "";
    for(const art of ART_LIST){
      const isUnlocked = !!unlocked[art.id];
      const el = document.createElement("div");
      el.className = "card";

      const img = document.createElement("img");
      img.className = "thumb";
      img.src = art.src;
      img.alt = art.name;
      img.loading = "lazy";
      el.appendChild(img);

      if(!isUnlocked){
        const lock = document.createElement("div");
        lock.className = "lock";
        lock.textContent = "LOCK";
        el.appendChild(lock);
        img.style.filter = "blur(10px) saturate(0.2)";
      }

      const cap = document.createElement("div");
      cap.className = "cap";
      const left = document.createElement("span");
      left.textContent = art.name;
      const right = document.createElement("span");
      right.textContent = isUnlocked ? `BEST ${best[art.id] ?? "--"}` : "";
      cap.appendChild(left);
      cap.appendChild(right);
      el.appendChild(cap);

      el.addEventListener("click", () => {
        if(!isUnlocked){
          showToast("ã¾ãšã¯ã‚¹ãƒˆãƒƒãƒ—ã§è§£æ”¾ã—ã¦ã­ï¼");
          return;
        }
        state.currentArtIndex = ART_LIST.findIndex(a => a.id === art.id);
        closeGallery();
        loadCurrentImage();
        showToast("ã“ã®çµµã§éŠã¶ï¼");
      });

      grid.appendChild(el);
    }
  }

  // ===== Game scratch =====
  function toCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (W / rect.width);
    const y = (e.clientY - rect.top)  * (H / rect.height);
    return {x,y};
  }

  function addDust(x,y, amount, dirx, diry){
    for(let i=0;i<amount;i++){
      particles.push({
        x, y,
        vx: (dirx + (Math.random()-0.5)*0.8) * (2.0 + Math.random()*1.6),
        vy: (diry + (Math.random()-0.5)*0.8) * (2.0 + Math.random()*1.6),
        life: 18 + Math.random()*16,
        r: 1.4 + Math.random()*2.6,
        a: 0.9
      });
    }
  }

  function drawParticles(c){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.92;
      p.vy = p.vy*0.92 + 0.25;
      p.life -= 1;
      p.a *= 0.96;

      c.save();
      c.globalAlpha = Math.max(0, p.a);
      c.fillStyle = (Math.random()<0.6) ? "rgba(255,255,255,.9)" : "rgba(230,210,185,.9)";
      c.beginPath();
      c.arc(p.x, p.y, p.r, 0, Math.PI*2);
      c.fill();
      c.restore();

      if (p.life <= 0 || p.a <= 0.03) particles.splice(i,1);
    }
  }

  function scratchLine(a,b){
    const tp = toolParams();
    const dx = b.x-a.x, dy = b.y-a.y;
    const dist = Math.hypot(dx,dy);
    const steps = Math.max(1, Math.ceil(dist / (tp.radius*0.55)));
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = a.x + dx*t;
      const y = a.y + dy*t;
      scratchPoint(x,y, dx,dy, dist);
    }
  }

  function scratchPoint(x,y, dx,dy, dist){
    if (state.frozen) return;

    const tp = toolParams();

    // é£´æ¿ç¯„å›²ã®ã¿
    if (x<150 || x>W-150 || y<260 || y>900) return;

    // å‰Šã‚‹ï¼ˆè¦‹ãŸç›®ï¼‰
    sctx.save();
    sctx.globalCompositeOperation = "destination-out";
    sctx.beginPath();
    sctx.arc(x, y, tp.radius, 0, Math.PI*2);
    sctx.fill();
    sctx.restore();

    // ç²‰
    const len = Math.hypot(dx,dy) || 1;
    addDust(x,y, Math.round(2 + tp.radius*0.18), dx/len, dy/len);

    // æ¡ç‚¹
    const r = state.imgRect;
    const em = state.edgeMap;

    const overWork = state.lastPt
      ? (1 - Math.min(1, Math.hypot(x-state.lastPt.x, y-state.lastPt.y) / (tp.radius*1.2)))
      : 0;
    state.overWorkSum += overWork;

    if(!r || !em || !state.hitEdge || !state.badMask){
      calcScore(); updateUI();
      return;
    }

    const ix = Math.floor((x - r.x) / r.w * em.w);
    const iy = Math.floor((y - r.y) / r.h * em.h);

    if(ix < 0 || iy < 0 || ix >= em.w || iy >= em.h){
      state.badCount += 0.2; // å¤–ã¯è»½ãæ¸›ç‚¹
    } else {
      const idx = iy*em.w + ix;
      const onEdge = em.band[idx] === 1;

      if(onEdge){
        if(state.hitEdge[idx] === 0){
          state.hitEdge[idx] = 1;
          state.goodCount += 1;
        }
      } else {
        if(state.badMask[idx] === 0){
          state.badMask[idx] = 1;
          state.badCount += 1;
        }
      }
    }

    calcScore();
    updateUI();
  }

  // ===== Render =====
  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.drawImage(base, 0,0);
    ctx.drawImage(sugar, 0,0);
    drawParticles(ctx);

    if(state.showResult){
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.globalAlpha = 0.96;
      ctx.font = "900 64px -apple-system, system-ui, sans-serif";
      ctx.fillText("RESULT", 90, 1020);

      ctx.font = "900 44px -apple-system, system-ui, sans-serif";
      ctx.fillText(`${Math.round(state.score)} ç‚¹`, 90, 1080);

      ctx.font = "900 28px -apple-system, system-ui, sans-serif";
      ctx.fillText(`RANK: ${state.rank}`, 90, 1120);

      ctx.font = "700 18px -apple-system, system-ui, sans-serif";
      ctx.fillText(`è¼ªéƒ­ã‚«ãƒãƒ¼: ${Math.round(state.coverage*100)}%   ã¯ã¿å‡ºã—: ${Math.round(state.overcut*100)}%`, 90, 1152);
      ctx.restore();
    }

    requestAnimationFrame(render);
  }

  // ===== Input =====
  let isDown = false;
  function onDown(e){
    if(state.frozen) return;
    e.preventDefault();
    const p = toCanvasPos(e);
    isDown = true;
    state.lastPt = p;
  }
  function onMove(e){
    if(state.frozen) return;
    if (!isDown) return;
    e.preventDefault();
    const p = toCanvasPos(e);
    if (state.lastPt) scratchLine(state.lastPt, p);
    else scratchPoint(p.x,p.y, 0,0, 0);
    state.lastPt = p;
  }
  function onUp(e){
    if(state.frozen) return;
    if (!isDown) return;
    e.preventDefault();
    isDown = false;
    state.lastPt = null;
  }

  canvas.addEventListener('pointerdown', onDown, {passive:false});
  canvas.addEventListener('pointermove', onMove, {passive:false});
  canvas.addEventListener('pointerup', onUp, {passive:false});
  canvas.addEventListener('pointercancel', onUp, {passive:false});
  canvas.addEventListener('pointerleave', onUp, {passive:false});

  // ===== Stop / Result =====
  function stopAndScore(){
    if(state.frozen) return;
    state.frozen = true;
    state.showResult = true;

    // æœ€çµ‚ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼†ä¿å­˜
    calcScore();
    updateUI();
    unlockAndSaveBest();

    showToast(`æ¡ç‚¹ï¼ ${Math.round(state.score)}ç‚¹ï¼ˆ${state.rank}ï¼‰`);
  }

  // Buttons
  btnStop.addEventListener('click', stopAndScore);

  btnReset.addEventListener('click', () => resetGame(true));

  btnNext.addEventListener('click', () => {
    state.currentArtIndex = (state.currentArtIndex + 1) % ART_LIST.length;
    loadCurrentImage();
    showToast("æ¬¡ã®çµµï¼");
  });

  btnTool.addEventListener('click', () => {
    state.toolIndex = (state.toolIndex + 1) % 3;
    updateUI();
    showToast("é‡ï¼š " + toolParams().name);
  });

  btnGallery.addEventListener('click', openGallery);
  btnClose.addEventListener('click', closeGallery);
  modal.addEventListener('click', (e) => { if (e.target === modal) closeGallery(); });

  btnClear.addEventListener('click', () => {
    clearUnlocked();
    localStorage.removeItem(BEST_KEY);
    renderGallery();
    showToast("ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆï¼");
  });

  // Start
  updateUI();
  resetGame(true);
  loadCurrentImage();
  render();
})();
</script>
</body>
</html>